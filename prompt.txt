
========================================
cmd\choretracker\app\actions\action_add.go
package actions

import (
	"context"
	"fmt"

	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/delivery/parser"
	"github.com/Galdoba/choretracker/internal/delivery/tui"
	"github.com/Galdoba/choretracker/internal/utils"
	"github.com/urfave/cli/v3"
)

func AddAction(actx *appcontext.AppContext) cli.ActionFunc {
	return func(ctx context.Context, c *cli.Command) error {
		ts := actx.GetService()
		r, err := parser.ParseCliCommand(c)
		if err != nil {
			ts.Logger.Errorf("failed to parse request: %v", err)
			return fmt.Errorf("failed to parse request: %v", err)
		}
		mode := c.String(flags.GLOBAL_MODE)
		switch mode {
		case flags.VALUE_MODE_CLI:
			//do nothing: expected to have data from flags --title and --shedule
		case flags.VALUE_MODE_TUI:
			if err := tui.EditRequest(&r); err != nil {
				return utils.LogError(ts.Logger, "failed to edit request", err)
			}
		case flags.VALUE_MODE_SERVER:
			return fmt.Errorf("server mode not implemented")
		}

		if _, err := ts.ServeRequest(r); err != nil {
			ts.Logger.Errorf("task failed: %v", err)
			return err
		}
		return err
	}
}

========================================
cmd\choretracker\app\actions\action_config.go
package actions

import (
	"context"
	"fmt"
	"os"

	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/utils"
	"github.com/urfave/cli/v3"
)

func ConfigAction(actx *appcontext.AppContext) cli.ActionFunc {
	return func(ctx context.Context, c *cli.Command) error {
		logger := actx.GetLogger()
		logger.Infof("configuration data requested")
		cfg := actx.Config()
		cfgPath := actx.ConfigPath()
		if cfgPath == "" {
			return utils.LogError(logger, "config filepath not found", nil)
		}
		fmt.Fprintf(os.Stderr, "configuration file can be found at:\n%v\n", cfgPath)

		logpath := actx.LogfilePath()
		if logpath == "" {
			return utils.LogError(logger, "log filepath not found", nil)
		}
		fmt.Fprintf(os.Stderr, "logfile can be found at:\n%v\n\n", logpath)
		fmt.Fprintf(os.Stderr, "%v\n", cfg.String())
		return nil
	}
}

========================================
cmd\choretracker\app\actions\action_delete.go
package actions

import (
	"context"
	"fmt"

	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/delivery/parser"
	"github.com/Galdoba/choretracker/internal/delivery/tui"
	"github.com/urfave/cli/v3"
)

func DeleteAction(actx *appcontext.AppContext) cli.ActionFunc {
	return func(ctx context.Context, c *cli.Command) error {
		ts := actx.GetService()
		req, err := parser.ParseCliCommand(c)
		if err != nil {
			ts.Logger.Errorf("failed to parse request: %v", err)
			return fmt.Errorf("failed to parse request: %v", err)
		}

		mode := c.String(flags.GLOBAL_MODE)
		switch mode {
		case "":
			return fmt.Errorf("run mode not set\nuse '--run-mode' flag")
		case flags.VALUE_MODE_CLI:
			_, err := ts.ServeRequest(req)
			if err != nil {
				ts.Logger.Errorf("task failed: %v", err)
				return err
			}
		case flags.VALUE_MODE_TUI:
			chr, err := tui.SelectChore(ts)
			if err != nil {
				ts.Logger.Errorf("task failed: %v", err)
				return err
			}
			if id, ok := chr.GetID(); ok {
				req.InjectID(id)
			}
			_, err = ts.ServeRequest(req)
			if err != nil {
				ts.Logger.Errorf("task failed: %v", err)
				return err
			}
		default:
			return fmt.Errorf("unknown mode '%v'", mode)

		}

		return err
	}
}

========================================
cmd\choretracker\app\actions\action_get.go
package actions

import (
	"context"
	"fmt"
	"os"

	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/core/domain"
	"github.com/Galdoba/choretracker/internal/delivery/parser"
	"github.com/Galdoba/choretracker/internal/delivery/tui"
	"github.com/Galdoba/choretracker/internal/utils"
	"github.com/urfave/cli/v3"
)

func GetAction(actx *appcontext.AppContext) cli.ActionFunc {
	return func(ctx context.Context, c *cli.Command) error {
		ts := actx.GetService()

		req, err := parser.ParseCliCommand(c)
		if err != nil {
			ts.Logger.Errorf("failed to parse request: %v", err)
			return fmt.Errorf("failed to parse request: %v", err)
		}

		got := &domain.Chore{}
		mode := c.String(flags.GLOBAL_MODE)
		switch mode {
		case "":
			return fmt.Errorf("run mode not set\nuse '--run-mode' flag")
		case flags.VALUE_MODE_CLI:
			chr, err := ts.ServeRequest(req)
			if err != nil {
				ts.Logger.Errorf("task failed: %v", err)
				return err
			}
			got = chr
		case flags.VALUE_MODE_TUI:
			got, err := tui.SelectChore(ts)
			if err != nil {
				ts.Logger.Errorf("task failed: %v", err)
				return err
			}
			if id, ok := got.GetID(); ok {
				req.InjectID(id)
			}
			got, err = ts.ServeRequest(req)
			if err != nil {
				return utils.LogError(ts.Logger, "read chore failed", err)
			}
		default:
			return fmt.Errorf("unknown mode '%v'", mode)

		}

		fmt.Fprintf(os.Stdout, "%v", got.String())

		return err
	}
}

========================================
cmd\choretracker\app\actions\action_update.go
package actions

import (
	"context"
	"fmt"

	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/delivery/parser"
	"github.com/Galdoba/choretracker/internal/delivery/tui"
	"github.com/Galdoba/choretracker/internal/utils"
	"github.com/urfave/cli/v3"
)

func UpdateAction(actx *appcontext.AppContext) cli.ActionFunc {
	return func(ctx context.Context, c *cli.Command) error {
		ts := actx.GetService()
		r, err := parser.ParseCliCommand(c)
		if err != nil {
			ts.Logger.Errorf("failed to parse request: %v", err)
			return fmt.Errorf("failed to parse request: %v", err)
		}
		// got := &domain.Chore{}
		mode := c.String(flags.GLOBAL_MODE)
		switch mode {
		case "":
			return fmt.Errorf("run mode not set\nuse '--run-mode' flag")
		case flags.VALUE_MODE_CLI:
			_, err = ts.ServeRequest(r)
			if err != nil {
				ts.Logger.Errorf("task failed: %v", err)
				return err
			}
		case flags.VALUE_MODE_TUI:
			chr, err := tui.SelectChore(ts)
			if err != nil {
				ts.Logger.Errorf("task failed: %v", err)
				return err
			}
			if id, ok := chr.GetID(); ok {
				r.InjectID(id)
				r.InjectContent(chr.Content())
			}

			if err := tui.EditRequest(&r); err != nil {
				return utils.LogError(ts.Logger, "failed to edit request", err)
			}
			if _, err := ts.ServeRequest(r); err != nil {
				// got = updated
				return utils.LogError(ts.Logger, "failed to update chore", err)
			}
		default:
			return fmt.Errorf("unknown mode '%v'", mode)
		}

		return err
	}
}

========================================
cmd\choretracker\app\actions\run.go
package actions

import (
	"context"
	"fmt"

	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/urfave/cli/v3"
)

func Start(actx *appcontext.AppContext) cli.ActionFunc {
	return func(ctx context.Context, c *cli.Command) error {
		fmt.Println("start Start action")
		return nil
	}
}

========================================
cmd\choretracker\app\command.go
package app

import (
	"github.com/Galdoba/choretracker/cmd/choretracker/app/actions"
	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/cmd/choretracker/app/subcommands"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/urfave/cli/v3"
)

func NewApp(actx *appcontext.AppContext) *cli.Command {
	cmd := cli.Command{
		Name:        constants.AppName,
		Aliases:     []string{},
		Usage:       "enchanced todo app for learning",
		Version:     constants.Version,
		Description: "this app was writen to grasp DDD and hexogonal achitecture",
		Commands: []*cli.Command{
			subcommands.AddChore(actx),
			subcommands.GetChore(actx),
			subcommands.UpdateChore(actx),
			subcommands.DeleteChore(actx),
			subcommands.Config(actx),
		},
		Flags: []cli.Flag{
			&flags.MODE,
		},
		Action:  actions.Start(actx),
		Authors: []any{constants.Author},
	}
	return &cmd
}

========================================
cmd\choretracker\app\flags\global.go
package flags

import (
	"github.com/urfave/cli/v3"
)

const (
	GLOBAL_MODE       = "run-mode"
	VALUE_MODE_CLI    = "cli"
	VALUE_MODE_TUI    = "tui"
	VALUE_MODE_SERVER = "server"
	CHORE_TITLE       = "title"
	CHORE_DESCRIPTION = "description"
	CHORE_AUTHOR      = "author"
	CHORE_SCHEDULE    = "schedule"
	CHORE_COMMENT     = "comment"
	CHORE_ID          = "id"
)

var MODE = cli.StringFlag{
	Name:        GLOBAL_MODE,
	Usage:       "'tui', 'cli' or 'server'",
	DefaultText: "tui",
	Value:       "tui",
}

var TITLE = cli.StringFlag{
	Name:    CHORE_TITLE,
	Usage:   "use chore title variable",
	Aliases: []string{"t"},
}

var DESCRIPTION = cli.StringFlag{
	Name:    CHORE_DESCRIPTION,
	Usage:   "use chore description variable",
	Aliases: []string{"d"},
}

var AUTHOR = cli.StringFlag{
	Name:    CHORE_AUTHOR,
	Usage:   "use chore author variable",
	Aliases: []string{"a"},
}

var SHEDULE = cli.StringFlag{
	Name:    CHORE_SCHEDULE,
	Usage:   "use chore schedule variable",
	Aliases: []string{"s"},
}

var COMMENT = cli.StringFlag{
	Name:    CHORE_COMMENT,
	Usage:   "use chore comment variable",
	Aliases: []string{"c"},
}

var ID = cli.Int64Flag{
	Name:        CHORE_ID,
	Usage:       "use chore id variable (required for cli-mode)",
	Aliases:     []string{"i"},
	HideDefault: true,
}

========================================
cmd\choretracker\app\subcommands\addChore.go
package subcommands

import (
	"github.com/Galdoba/choretracker/cmd/choretracker/app/actions"
	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/urfave/cli/v3"
)

func AddChore(actx *appcontext.AppContext) *cli.Command {
	add := cli.Command{
		Name:      constants.AddCommand,
		Aliases:   []string{},
		Usage:     "add new chore",
		UsageText: "choretracler [global options] add [options]",
		Version:   constants.Version,
		Flags: []cli.Flag{
			&flags.TITLE,
			&flags.DESCRIPTION,
			&flags.AUTHOR,
			&flags.SHEDULE,
			&flags.COMMENT,
		},
		Action: actions.AddAction(actx),
	}
	return &add
}

========================================
cmd\choretracker\app\subcommands\config.go
package subcommands

import (
	"github.com/Galdoba/choretracker/cmd/choretracker/app/actions"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/urfave/cli/v3"
)

func Config(actx *appcontext.AppContext) *cli.Command {
	add := cli.Command{
		Name:      constants.ConfigCommand,
		Usage:     "print current config file",
		UsageText: "choretracker config",
		Version:   constants.Version,
		Action:    actions.ConfigAction(actx),
	}
	return &add
}

========================================
cmd\choretracker\app\subcommands\deleteChore.go
package subcommands

import (
	"github.com/Galdoba/choretracker/cmd/choretracker/app/actions"
	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/urfave/cli/v3"
)

func DeleteChore(actx *appcontext.AppContext) *cli.Command {
	add := cli.Command{
		Name:      constants.DeleteCommand,
		Usage:     "delete chore",
		UsageText: "choretracker [global options] delete [options]",
		Version:   constants.Version,
		Flags: []cli.Flag{
			&flags.ID,
		},
		Action: actions.DeleteAction(actx),
	}
	return &add
}

========================================
cmd\choretracker\app\subcommands\getChore.go
package subcommands

import (
	"github.com/Galdoba/choretracker/cmd/choretracker/app/actions"
	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/urfave/cli/v3"
)

func GetChore(actx *appcontext.AppContext) *cli.Command {
	add := cli.Command{
		Name:      constants.GetCommand,
		Usage:     "get chore data",
		UsageText: "choretracler [global options] get [options]",
		Version:   constants.Version,
		Flags: []cli.Flag{
			&flags.ID,
		},
		Action: actions.GetAction(actx),
	}
	return &add
}

========================================
cmd\choretracker\app\subcommands\updateChore.go
package subcommands

import (
	"github.com/Galdoba/choretracker/cmd/choretracker/app/actions"
	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/urfave/cli/v3"
)

func UpdateChore(actx *appcontext.AppContext) *cli.Command {
	add := cli.Command{
		Name:      constants.UpdateCommand,
		Usage:     "update chore data",
		UsageText: "choretracker [global options] update [options]",
		Version:   constants.Version,
		Flags: []cli.Flag{
			&flags.ID,
			&flags.TITLE,
			&flags.DESCRIPTION,
			&flags.AUTHOR,
			&flags.SHEDULE,
			&flags.COMMENT,
		},
		Action: actions.UpdateAction(actx),
	}
	return &add
}

========================================
cmd\choretracker\main.go
package main

import (
	"context"
	"fmt"
	"os"

	"github.com/Galdoba/choretracker/cmd/choretracker/app"
	"github.com/Galdoba/choretracker/internal/appcontext"
	"github.com/Galdoba/choretracker/internal/constants"
)

func main() {
	actx, err := appcontext.InitCli(constants.AppName)
	if err != nil {
		fmt.Fprintf(os.Stderr, "initiation: %v", err)
		os.Exit(1)
	}
	program := app.NewApp(actx)

	if err := program.Run(context.Background(), os.Args); err != nil {
		fmt.Fprintf(os.Stderr, "%v run error: %v", constants.AppName, err)
		os.Exit(1)
	}
}

========================================
internal\appcontext\config.go
package appcontext

import (
	"path/filepath"

	"github.com/Galdoba/appcontext/xdg"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/pelletier/go-toml/v2"
)

type Config struct {
	Version      string                    `toml:"version,omitempty"`
	StoragePath  string                    `toml:"storage_path,omitempty"`
	Log          LoggerConfiguration       `toml:"Logger"`
	Notification NotificationConfiguration `toml:"Notification"`
}

type LoggerConfiguration struct {
	Enabled       bool   `toml:"enabled"`
	Level         string `toml:"level"`
	FilePath      string `toml:"filepath,omitempty"`
	ConsoleOutput bool   `toml:"console output"`
	ConsoleColors bool   `toml:"console color"`
}

type NotificationConfiguration struct {
	Enabled  bool            `toml:"enabled"`
	NotifyAt []string        `toml:"notify_at"`
	Methods  map[string]bool `toml:"methods_enabled"`
}

func defaultConfig(paths *xdg.ProgramPaths) Config {
	return Config{
		Version:     constants.Version,
		StoragePath: filepath.Join(paths.PersistentDataDir(), constants.StorageFile),
		Log: LoggerConfiguration{
			Enabled:       true,
			Level:         "debug",
			FilePath:      "",
			ConsoleOutput: true,
			ConsoleColors: false,
		},
		Notification: NotificationConfiguration{
			Enabled:  false,
			NotifyAt: []string{"07:00", "21:30"},
			Methods: map[string]bool{
				"console":   true,
				"os_notify": true,
				"telegram":  false,
			},
		},
	}
}

func (cfg *Config) String() string {
	s := ""
	data, err := toml.Marshal(cfg)
	switch err == nil {
	case false:
		s += err.Error()
	case true:
		s = string(data)
	}
	return s
}

========================================
internal\appcontext\initCli.go
package appcontext

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/Galdoba/appcontext/configmanager"
	"github.com/Galdoba/appcontext/logmanager"
	"github.com/Galdoba/appcontext/xdg"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/Galdoba/choretracker/internal/core/services"
	"github.com/Galdoba/choretracker/internal/infrastructure"
	"github.com/Galdoba/choretracker/internal/infrastructure/storage"
)

const (
	config  = "config"
	logfile = "logfile"
)

type AppContext struct {
	config  *Config
	log     Logger
	paths   map[string]string
	service *services.TaskService
}

func (actx *AppContext) Config() *Config {
	return actx.config
}

func (actx *AppContext) GetLogger() Logger {
	return actx.log
}

func (actx *AppContext) ConfigPath() string {
	return actx.paths[config]
}

func (actx *AppContext) LogfilePath() string {
	return actx.paths[logfile]
}

func (actx *AppContext) GetService() *services.TaskService {
	return actx.service
}

func InitCli(appname string) (*AppContext, error) {
	actx := AppContext{}
	actx.paths = make(map[string]string)

	paths := xdg.New(constants.AppName)
	actx.paths[config] = paths.ConfigFile()
	actx.paths[logfile] = paths.LogFile()

	cfgman, err := configmanager.New(appname, defaultConfig(paths))
	if err != nil {
		return nil, fmt.Errorf("config init failed: %v", err)
	}
	if err := cfgman.Load(); err != nil {
		fmt.Fprintf(os.Stderr, "config loading failed: %v\nfallback to default configuration...\n", err)
	}
	actx.config = cfgman.Config()
	logHandlers := []*logmanager.MessageHandler{}
	if actx.config.Log.ConsoleOutput {
		logHandlers = append(logHandlers,
			logmanager.NewHandler(
				logmanager.Stderr,
				logmanager.StringToLevel(actx.config.Log.Level),
				logmanager.NewTextFormatter(
					logmanager.WithTimePrecision(0),
					logmanager.WithLevelTag(true),
					logmanager.WithColor(true),
				),
			),
		)
	}
	logHandlers = append(logHandlers,
		logmanager.NewHandler(
			paths.LogFile(),
			logmanager.LevelDebug,
			logmanager.NewTextFormatter(
				logmanager.WithTimePrecision(0),
				logmanager.WithLevelTag(true),
				logmanager.WithColor(false),
			),
		),
	)
	actx.log = logmanager.New(logmanager.WithHandlers(logHandlers...))
	if err := confirmFile(actx.ConfigPath()); err != nil {
		return nil, err
	}
	if err := confirmFile(actx.LogfilePath()); err != nil {
		return nil, err
	}

	validator := infrastructure.DefaultValidator()
	store, err := storage.NewStorage(storage.JsonStorage, actx.config.StoragePath)
	if err != nil {
		return nil, fmt.Errorf("failed to setup storage: %v", err)
	}
	actx.service = services.NewTaskService(store, validator, actx.log)

	return &actx, nil
}

func confirmFile(path string) error {
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return fmt.Errorf("failed to create log directory: %v", err)
	}
	f, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open log file: %v", err)
	}
	defer f.Close()
	return nil
}

========================================
internal\appcontext\logger.go
package appcontext

type Logger interface {
	Debugf(string, ...any)
	Infof(string, ...any)
	Warnf(string, ...any)
	Errorf(string, ...any)
}

========================================
internal\constants\app.go
package constants

// App
const (
	AppName     = "choretracker"
	Version     = "0.3.0"
	Author      = "galdoba"
	StorageFile = "chores.json"
)

// Commands
const (
	AddCommand    = "add"
	GetCommand    = "get"
	UpdateCommand = "update"
	DeleteCommand = "delete"
	ConfigCommand = "config"
)

//Fields
const (
	Fld_Title    = "title"
	Fld_Descr    = "description"
	Fld_Author   = "author"
	Fld_Schedule = "schedule"
	Fld_Comment  = "comment"
)

========================================
internal\core\domain\chore.go
package domain

import (
	"fmt"
	"time"

	"github.com/Galdoba/choretracker/internal/constants"
)

func fields() []string {
	return []string{
		constants.Fld_Title, constants.Fld_Descr, constants.Fld_Author, constants.Fld_Schedule, constants.Fld_Comment,
	}
}

type Chore struct {
	ID               int64     `json:"id"`
	Title            string    `json:"title"`
	Description      string    `json:"description,omitempty"`
	Author           string    `json:"author"`
	Opened           time.Time `json:"opened"`
	NextNotification time.Time `json:"next notification"`
	Schedule         string    `json:"schedule"`
	Comment          string    `json:"comment,omitempty"`
}

func (ch *Chore) Key() string {
	return fmt.Sprintf("%v (id=%v)", ch.Title, ch.ID)
}

func (ch *Chore) String() string {
	s := ""
	s += fmt.Sprintf("chore  : %v (id=%v)\n", ch.Title, ch.ID)
	s += fmt.Sprintf("shedule: %v", ch.Schedule)
	if ch.Author != "" {
		s += fmt.Sprintf("\n author: %v", ch.Author)
	}
	if ch.Description != "" {
		s += fmt.Sprintf("\ndescription:\n  %v", ch.Description)
	}
	if ch.Comment != "" {
		s += fmt.Sprintf("\ncomment:\n  %v", ch.Comment)
	}
	return s
}

func (ch Chore) GetID() (int64, bool) {
	return ch.ID, true
}

func (ch Chore) Content() map[string]string {
	c := make(map[string]string)
	for i, key := range fields() {
		switch i {
		case 0:
			c[key] = ch.Title
		case 1:
			c[key] = ch.Description
		case 2:
			c[key] = ch.Author
		case 3:
			c[key] = ch.Schedule
		case 4:
			c[key] = ch.Comment
		}
	}
	return c
}
func (ch *Chore) GetTitle() (string, bool) {
	return ch.Title, true
}
func (ch *Chore) GetDescription() (string, bool) {
	return ch.Description, true
}
func (ch *Chore) GetAuthor() (string, bool) {
	return ch.Author, true
}
func (ch *Chore) GetOpened() time.Time {
	return ch.Opened
}
func (ch *Chore) GetNextNotification() time.Time {
	return ch.NextNotification
}
func (ch *Chore) GetSchedule() (string, bool) {
	return ch.Schedule, true
}
func (ch *Chore) GetComment() (string, bool) {
	return ch.Comment, true
}

func (ch *Chore) Validate() error {
	if ch.ID == 0 {
		return fmt.Errorf("id must not be 0")
	}
	if ch.Title == "" {
		return fmt.Errorf("title must be set")
	}
	if ch.Schedule == "" {
		return fmt.Errorf("schedule must be set")
	}
	return nil
}

========================================
internal\core\dto\request.go
package dto

import (
	"encoding/json"
	"fmt"

	"github.com/Galdoba/choretracker/internal/constants"
)

const (
	Create = "create"
	Read   = "read"
	Update = "update"
	Delete = "delete"
)

type ToServiceRequest struct {
	Action   string `json:"action" validate:"required"`
	Identity ChoreIdentity
	Fields   ChoreContent
}

func (res *ToServiceRequest) RequestType() string {
	return res.Action
}

type ChoreIdentity struct {
	ID *int64 `json:"id" validate:"required"`
}

func (ci *ChoreIdentity) GetID() (int64, bool) {
	if ci.ID == nil {
		return 0, false
	}
	if *ci.ID == 0 {
		return 0, false
	}
	return *ci.ID, true
}

type ChoreContent struct {
	Title       *string `json:"title" validate:"omitempty,min=1,max=255"`
	Description *string `json:"description" validate:"omitempty,max=1000"`
	Author      *string `json:"author" validate:"omitempty,min=1"`
	Schedule    *string `json:"schedule" validate:"omitempty"`
	Comment     *string `json:"comment" validate:"omitempty"`
}

func (cnt *ChoreContent) Content() map[string]string {
	c := make(map[string]string)
	if cnt.Title != nil {
		c[constants.Fld_Title] = *cnt.Title
	}
	if cnt.Description != nil {
		c[constants.Fld_Descr] = *cnt.Description
	}
	if cnt.Author != nil {
		c[constants.Fld_Author] = *cnt.Author
	}
	if cnt.Schedule != nil {
		c[constants.Fld_Schedule] = *cnt.Schedule
	}
	if cnt.Comment != nil {
		c[constants.Fld_Comment] = *cnt.Comment
	}
	return c
}

func UnmarshalRequest(data []byte) (ToServiceRequest, error) {
	req := ToServiceRequest{}
	if err := json.Unmarshal(data, &req); err != nil {
		return req, fmt.Errorf("failed to unmarshal request: %v", err)
	}
	return req, nil
}

func (req *ToServiceRequest) GetID() (int64, bool) {
	if req.Identity.ID == nil {
		return 0, false
	}
	return *req.Identity.ID, true
}

func (req *ToServiceRequest) InjectID(id int64) {
	if id == 0 {
		return
	}
	req.Identity.ID = &id
}

func (req *ToServiceRequest) InjectContent(content map[string]string) {
	if val, ok := content[constants.Fld_Title]; ok {
		req.Fields.Title = &val
	}
	if val, ok := content[constants.Fld_Descr]; ok {
		req.Fields.Description = &val
	}
	if val, ok := content[constants.Fld_Author]; ok {
		req.Fields.Author = &val
	}
	if val, ok := content[constants.Fld_Schedule]; ok {
		req.Fields.Schedule = &val
	}
	if val, ok := content[constants.Fld_Comment]; ok {
		req.Fields.Comment = &val
	}

}

///////////////////////depreacated

// type CreateRequest struct {
// 	ChoreContent
// }

// func UnmarshalCreateRequest(data []byte) (CreateRequest, error) {
// 	r := CreateRequest{}
// 	if err := json.Unmarshal(data, &r); err != nil {
// 		return r, err
// 	}
// 	return r, nil
// }

// func (cr *CreateRequest) Content() ChoreContent {
// 	return cr.ChoreContent
// }

// type ReadRequest struct {
// 	ChoreIdentity
// }

// func UnmarshalReadRequest(data []byte) (ReadRequest, error) {
// 	r := ReadRequest{}
// 	if err := json.Unmarshal(data, &r); err != nil {
// 		return r, err
// 	}
// 	return r, nil
// }

// func (cr *ReadRequest) Id() *int64 {
// 	return cr.ID
// }

// type UpdateRequest struct {
// 	ChoreIdentity
// 	ChoreContent
// }

// func UnmarshalUpdateRequest(data []byte) (UpdateRequest, error) {
// 	r := UpdateRequest{}
// 	if err := json.Unmarshal(data, &r); err != nil {
// 		return r, err
// 	}
// 	return r, nil
// }

// func (ur *UpdateRequest) Id() *int64 {
// 	return ur.ID
// }

// func (ur *UpdateRequest) Content() ChoreContent {
// 	return ur.ChoreContent
// }

// type DeleteRequest struct {
// 	ChoreIdentity
// }

// func UnmarshalDeleteRequest(data []byte) (DeleteRequest, error) {
// 	r := DeleteRequest{}
// 	if err := json.Unmarshal(data, &r); err != nil {
// 		return r, err
// 	}
// 	return r, nil
// }

// func (dr *DeleteRequest) Id() *int64 {
// 	return dr.ID
// }

========================================
internal\core\dto\responce.go
package dto

// type FromServiceResponce interface {
// 	GetID() (int64, bool)
// 	Content() map[string]string
// }

========================================
internal\core\ports\logger.go
package ports

type Logger interface {
	// Fatalf(string, ...any)
	Errorf(string, ...any)
	Warnf(string, ...any)
	Infof(string, ...any)
	Debugf(string, ...any)
}

========================================
internal\core\ports\storage.go
package ports

import "github.com/Galdoba/choretracker/internal/core/domain"

type Storage interface {
	Create(domain.Chore) error
	Read(int64) (domain.Chore, error)
	Update(domain.Chore) error
	Delete(int64) error
	GetAll() ([]domain.Chore, error)
}

========================================
internal\core\ports\validator.go
package ports

import (
	"github.com/Galdoba/choretracker/internal/core/dto"
)

type Validator interface {
	ValidateRequest(dto.ToServiceRequest) error
}

========================================
internal\core\services\service.go
package services

import (
	"errors"
	"fmt"
	"os/user"
	"path/filepath"
	"time"

	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/Galdoba/choretracker/internal/core/domain"
	"github.com/Galdoba/choretracker/internal/core/dto"
	"github.com/Galdoba/choretracker/internal/core/ports"
	"github.com/Galdoba/choretracker/internal/utils"
	"github.com/Galdoba/choretracker/pkg/cronexpr"
)

type TaskService struct {
	Storage   ports.Storage
	Validator ports.Validator
	Logger    ports.Logger
}

func NewTaskService(storage ports.Storage, validator ports.Validator, logger ports.Logger) *TaskService {
	return &TaskService{
		Storage:   storage,
		Validator: validator,
		Logger:    logger,
	}
}

func (ts *TaskService) ServeRequest(req dto.ToServiceRequest) (*domain.Chore, error) {
	switch req.Action {
	case dto.Create:
		return ts.CreateTask(req)
	case dto.Read:
		return ts.ReadTask(req)
	case dto.Update:
		return ts.UpdateTask(req)
	case dto.Delete:
		return ts.DeleteTask(req)
	default:
		return nil, fmt.Errorf("unknown request type: %v", req.RequestType())
	}
}

func (ts *TaskService) CreateTask(req dto.ToServiceRequest) (*domain.Chore, error) {
	ch := domain.Chore{}
	if err := ts.Validator.ValidateRequest(req); err != nil {
		return nil, utils.LogError(ts.Logger, "invalid request", err)
	}
	ch, err := newChoreFromRequest(req)
	if err != nil {
		return nil, utils.LogError(ts.Logger, "failed to create new chore", err)
	}
	if err := ch.Validate(); err != nil {
		return nil, utils.LogError(ts.Logger, "failed to validate chore", err)
	}
	if err := updateNotificationTime(&ch); err != nil {
		return nil, utils.LogError(ts.Logger, "failed to update notification time", err)
	}
	if err := ts.Storage.Create(ch); err != nil {
		return nil, utils.LogError(ts.Logger, "failed to create chore in storage", err)
	}
	ts.Logger.Infof("new chore created: %v (id=%v)", ch.Title, ch.ID)
	return &ch, nil
}

func newChoreFromRequest(req dto.ToServiceRequest) (domain.Chore, error) {
	ch := domain.Chore{}
	if req.Action != dto.Create {
		return ch, fmt.Errorf("request type is not '%v'", dto.Create)
	}
	openTime := time.Now()
	ch.ID = openTime.Unix()
	ch.Opened = openTime

	updateChore(&ch, req.Fields.Content())

	if ch.Author == "" {
		currentUser, err := user.Current()
		if err != nil {
			return ch, fmt.Errorf("failed to get current username: %v", err)
		}
		ch.Author = filepath.Base(currentUser.Username)
	}

	return ch, nil
}

func (ts TaskService) logError(msg string, err error) error {
	ts.Logger.Errorf(msg)
	if err == nil {
		return errors.New(msg)
	}
	return fmt.Errorf("%v: %v", msg, err)
}

func loadFromStorage(ts *TaskService, id int64) (domain.Chore, error) {
	if id == 0 {
		return domain.Chore{}, utils.LogError(ts.Logger, "id can't be equal to 0", nil)
	}

	ch, err := ts.Storage.Read(id)
	if err != nil {
		return domain.Chore{}, utils.LogError(ts.Logger, "failed to read from storage", err)
	}
	return ch, nil
}

func (ts *TaskService) ReadTask(req dto.ToServiceRequest) (*domain.Chore, error) {
	ch := domain.Chore{}
	if err := ts.Validator.ValidateRequest(req); err != nil {
		return nil, utils.LogError(ts.Logger, "invalid request", err)
	}
	ch, err := loadFromStorage(ts, *req.Identity.ID)
	if err != nil {
		return nil, err
	}
	ts.Logger.Infof("chore read: '%v' (id=%v)", ch.Title, ch.ID)
	return &ch, nil
}

func (ts *TaskService) UpdateTask(req dto.ToServiceRequest) (*domain.Chore, error) {
	ch := domain.Chore{}
	if err := ts.Validator.ValidateRequest(req); err != nil {
		return nil, utils.LogError(ts.Logger, "invalid request", err)
	}
	ch, err := loadFromStorage(ts, *req.Identity.ID)
	if err != nil {
		return nil, err
	}

	updateChore(&ch, req.Fields.Content())

	if err := updateNotificationTime(&ch); err != nil {
		return nil, ts.logError("failed to update notification time", err)
	}
	if err := ts.Storage.Update(ch); err != nil {
		return nil, ts.logError("failed to update chore in storage", err)
	}

	ts.Logger.Infof("chore updated: '%v' (id=%v)", ch.Title, ch.ID)
	return &ch, nil
}

func (ts *TaskService) DeleteTask(req dto.ToServiceRequest) (*domain.Chore, error) {
	if err := ts.Validator.ValidateRequest(req); err != nil {
		return nil, utils.LogError(ts.Logger, "invalid request", err)
	}
	ch, err := loadFromStorage(ts, *req.Identity.ID)
	if err != nil {
		return nil, utils.LogError(ts.Logger, "failed to load chore from storage", err)
	}
	title := ch.Title
	id := ch.ID
	if err := ts.Storage.Delete(ch.ID); err != nil {
		return nil, utils.LogError(ts.Logger, "failed to delete chore", err)
	}
	ts.Logger.Infof("chore deleted: '%v' (id=%v)", title, id)
	return nil, nil
}

func updateNotificationTime(ch *domain.Chore) error {
	exp, err := cronexpr.Parse(ch.Schedule)
	if err != nil {
		return fmt.Errorf("failed to parse chore shedule: %v", err)
	}
	ch.NextNotification = exp.Next(time.Now())
	return nil
}

func updateChore(ch *domain.Chore, c map[string]string) {
	if title, ok := c[constants.Fld_Title]; ok {
		ch.Title = setUpdated(ch.Title, title)
	}
	if desc, ok := c[constants.Fld_Descr]; ok {
		ch.Description = setUpdated(ch.Description, desc)
	}
	if author, ok := c[constants.Fld_Author]; ok {
		ch.Author = setUpdated(ch.Author, author)
	}
	if schedule, ok := c[constants.Fld_Schedule]; ok {
		ch.Schedule = setUpdated(ch.Schedule, schedule)
	}
	if comment, ok := c[constants.Fld_Comment]; ok {
		ch.Comment = setUpdated(ch.Comment, comment)
	}
}

func setUpdated(old string, new string) string {
	return utils.SetUpdatedField(old, &new)
}

========================================
internal\delivery\parser\cli_parsers.go
package parser

import (
	"fmt"

	"github.com/Galdoba/choretracker/cmd/choretracker/app/flags"
	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/Galdoba/choretracker/internal/core/dto"
	"github.com/urfave/cli/v3"
)

func ParseCliCommand(c *cli.Command) (dto.ToServiceRequest, error) {
	req := dto.ToServiceRequest{}
	switch c.Name {
	case constants.AddCommand:
		req.Action = dto.Create
		req.Identity = parseID(c)
		req.Fields = parseContent(c)
	case constants.GetCommand:
		req.Action = dto.Read
		req.Identity = parseID(c)
		req.Fields = parseContent(c)
	case constants.UpdateCommand:
		req.Action = dto.Update
		req.Identity = parseID(c)
		req.Fields = parseContent(c)
	case constants.DeleteCommand:
		req.Action = dto.Delete
		req.Identity = parseID(c)
		req.Fields = parseContent(c)
	default:
		return req, fmt.Errorf("failed to parse command flags")
	}
	return req, nil
}

// func ParseCliArgsCreate(c *cli.Command) (dto.CreateRequest, error) {
// 	r := dto.CreateRequest{}
// 	switch c.Name {
// 	case constants.AddCommand:
// 		r.ChoreContent = parseContent(c)
// 	default:
// 		return r, fmt.Errorf("command '%v' does not use CreateRequest", c.Name)
// 	}
// 	return r, nil
// }

// func ParseCliArgsRead(c *cli.Command) (dto.ReadRequest, error) {
// 	r := dto.ReadRequest{}
// 	switch c.Name {
// 	case constants.GetCommand:
// 		r.ChoreIdentity = parseID(c)
// 	default:
// 		return r, fmt.Errorf("command '%v' does not use ReadRequest", c.Name)
// 	}
// 	return r, nil
// }

// func ParseCliArgsUpdate(c *cli.Command) (dto.UpdateRequest, error) {
// 	r := dto.UpdateRequest{}
// 	switch c.Name {
// 	case constants.UpdateCommand:
// 		r.ChoreIdentity = parseID(c)
// 		r.ChoreContent = parseContent(c)
// 	default:
// 		return r, fmt.Errorf("command '%v' does not use UpdateRequest", c.Name)
// 	}
// 	return r, nil
// }

// func ParseCliArgsDelete(c *cli.Command) (dto.DeleteRequest, error) {
// 	r := dto.DeleteRequest{}
// 	switch c.Name {
// 	case constants.DeleteCommand:
// 		r.ChoreIdentity = parseID(c)
// 	default:
// 		return r, fmt.Errorf("command '%v' does not use DeleteRequest", c.Name)
// 	}
// 	return r, nil
// }

func parseContent(c *cli.Command) dto.ChoreContent {
	cntnt := dto.ChoreContent{}
	for i, val := range []string{
		c.String(flags.CHORE_TITLE),
		c.String(flags.CHORE_DESCRIPTION),
		c.String(flags.CHORE_AUTHOR),
		c.String(flags.CHORE_SCHEDULE),
		c.String(flags.CHORE_COMMENT),
	} {
		switch i {
		case 0:
			cntnt.Title = &val
		case 1:
			cntnt.Description = &val
		case 2:
			cntnt.Author = &val
		case 3:
			cntnt.Schedule = &val
		case 4:
			cntnt.Comment = &val
		}
	}
	return cntnt
}

func parseID(c *cli.Command) dto.ChoreIdentity {
	id := dto.ChoreIdentity{}
	if val := c.Int64(flags.CHORE_ID); val != 0 {
		id.ID = &val
	}
	return id
}

========================================
internal\delivery\tui\editor.go
package tui

import (
	"fmt"

	"github.com/Galdoba/choretracker/internal/constants"
	"github.com/Galdoba/choretracker/internal/core/dto"
	"github.com/Galdoba/choretracker/pkg/cronexpr"
	"github.com/charmbracelet/huh"
)

type editor struct {
}

var e = &editor{}

func (e *editor) Edit(content map[string]string) (map[string]string, error) {
	title := content[constants.Fld_Title]
	desc := content[constants.Fld_Descr]
	schedule := content[constants.Fld_Schedule]
	comment := content[constants.Fld_Comment]
	form := huh.NewForm(
		huh.NewGroup(
			huh.NewInput().
				Title("chore title:").
				// Description(fmt.Sprintf("ID: %v", ch.ID)).
				Validate(validateName).
				Value(&title),
			huh.NewText().
				Title("description").
				Value(&desc).
				WithWidth(40).
				WithHeight(5),
			huh.NewInput().
				Title("cron shedule").
				Description("crontab expression: mm hh dom mon dow").
				Validate(validateShedule).
				Value(&schedule),
			huh.NewText().
				Title("comments").
				Value(&comment).
				WithWidth(40).
				WithHeight(5),
		),
	)
	if err := form.Run(); err != nil {
		return content, fmt.Errorf("failed to run chore editor form: %v", err)
	}
	content[constants.Fld_Title] = title
	content[constants.Fld_Descr] = desc
	content[constants.Fld_Schedule] = schedule
	content[constants.Fld_Comment] = comment
	return content, nil

}

func validateShedule(s string) error {
	_, err := cronexpr.Parse(s)
	if err != nil {
		return err
	}
	return nil

}

func validateName(s string) error {
	if s == "" {
		return fmt.Errorf("this fileld must not be empty")
	}
	return nil

}

func EditRequest(req *dto.ToServiceRequest) error {
	content, err := e.Edit(req.Fields.Content())
	if err != nil {
		return fmt.Errorf("failed to edit creation request: %v", err)
	}
	req.InjectContent(content)
	return nil
}

// func EditUpdateRequest(ur dto.UpdateRequest) (dto.UpdateRequest, error) {
// 	content := ur.Content()
// 	if err := e.Edit(&content); err != nil {
// 		return ur, fmt.Errorf("failed to edit creation request: %v", err)
// 	}
// 	return dto.UpdateRequest{
// 		ChoreIdentity: ur.ChoreIdentity,
// 		ChoreContent:  content,
// 	}, nil
// }

========================================
internal\delivery\tui\selector.go
package tui

import (
	"fmt"

	"github.com/Galdoba/choretracker/internal/core/domain"
	"github.com/Galdoba/choretracker/internal/core/services"
	"github.com/Galdoba/consolio/prompt"
)

type ChoreSelector struct {
	ts *services.TaskService
}

// SelectChore return chore selected by user from storage
func SelectChore(ts *services.TaskService) (*domain.Chore, error) {
	cs := ChoreSelector{ts}
	return cs.selectChore()
}

func (cs *ChoreSelector) selectChore() (*domain.Chore, error) {
	chr := domain.Chore{}
	chores, err := cs.ts.Storage.GetAll()
	if err != nil {
		return nil, fmt.Errorf("failed to get chore list from storage: %v", err)
	}
	// ids := []int64{}
	selectionPool := []*prompt.Item{}
	for _, ch := range chores {
		selectionPool = append(selectionPool, prompt.NewItem(fmt.Sprintf("id:%v (%v)", ch.ID, ch.Title), ch))
	}
	ch, err := prompt.SearchItem(prompt.WithTitle("search chores:"), prompt.FromItems(selectionPool))
	if err != nil {
		return nil, err
	}
	chr = ch.Payload().(domain.Chore)
	return &chr, nil
}

========================================
internal\infrastructure\storage\ims\inMemoryStorage.go
package ims

import (
	"fmt"
	"sync"

	"github.com/Galdoba/choretracker/internal/core/domain"
)

type InMemoryStorage struct {
	chores map[int64]domain.Chore
	mutext sync.Mutex
}

func NewInMemoryStorage() *InMemoryStorage {
	imStrg := InMemoryStorage{}
	imStrg.chores = make(map[int64]domain.Chore)
	return &imStrg
}

func (ims *InMemoryStorage) Create(ch domain.Chore) error {
	ims.mutext.Lock()
	defer ims.mutext.Unlock()

	if _, ok := ims.chores[ch.ID]; ok {
		return fmt.Errorf("chore %v already created", ch.ID)
	}

	ims.chores[ch.ID] = ch

	return nil
}

// Update(*chore.Chore) error
func (ims *InMemoryStorage) Update(ch domain.Chore) error {
	ims.mutext.Lock()
	defer ims.mutext.Unlock()

	if _, ok := ims.chores[ch.ID]; !ok {
		return fmt.Errorf("chore %v does not exist", ch.ID)
	}

	ims.chores[ch.ID] = ch

	return nil
}

// Read(int) (*chore.Chore, error)
func (ims *InMemoryStorage) Read(id int64) (domain.Chore, error) {
	ims.mutext.Lock()
	defer ims.mutext.Unlock()

	ch, ok := ims.chores[id]
	switch ok {
	default:
		return ch, fmt.Errorf("chore %v does not exist", id)
	case true:
		return ch, nil
	}
}

// Delete(*chore.Chore) error
func (ims *InMemoryStorage) Delete(id int64) error {
	ims.mutext.Lock()
	defer ims.mutext.Unlock()

	if _, ok := ims.chores[id]; !ok {
		return fmt.Errorf("chore %v does not exist", id)
	}

	delete(ims.chores, id)
	return nil
}

// GetAll() ([]*chore.Chore, error)
func (ims *InMemoryStorage) GetAll() ([]domain.Chore, error) {
	ims.mutext.Lock()
	defer ims.mutext.Unlock()

	chores := []domain.Chore{}
	for _, v := range ims.chores {
		chores = append(chores, v)

	}
	return chores, nil
}

========================================
internal\infrastructure\storage\js\jsonStore.go
package js

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"sync"

	"github.com/Galdoba/choretracker/internal/core/domain"
)

// AI generated comment:
// JsonStore represents a thread-safe storage for chores using JSON file as persistence
type JsonStore struct {
	filepath string
	Chores   map[int64]domain.Chore `json:"store"`
	mutex    sync.RWMutex
}

// AI generated comment:
// New creates a new JsonStore instance
// Initializes storage from existing file or creates new storage if file doesn't exist
// Uses path argument to locate or create the JSON storage file
func New(path string) (*JsonStore, error) {
	js := JsonStore{filepath: path, Chores: make(map[int64]domain.Chore)}
	switch fileExist(path) {
	case false:
		os.MkdirAll(filepath.Dir(path), 0755)
		f, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0664)
		if err != nil {
			return nil, fmt.Errorf("failed to create JsonStore file: %v", err)
		}
		defer f.Close()
		emptyData, err := json.Marshal(&js)
		if err != nil {
			return nil, fmt.Errorf("JsonStore template creation failed: %v", err)
		}
		if _, err := f.Write(emptyData); err != nil {
			return nil, fmt.Errorf("failed to save JsonStore template: %v", err)
		}
		return &js, nil
	case true:
		data, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("failed to read JsonStore file: %v", err)
		}
		if err := json.Unmarshal(data, &js); err != nil {
			return nil, fmt.Errorf("failed to ummarshal JsonStore data: %v", err)
		}
	}
	return &js, nil

}

// AI generated comment:
// save writes the current state of JsonStore to the associated JSON file
func (js *JsonStore) save() error {
	data, err := json.MarshalIndent(js, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal JsonStore: %v", err)
	}
	if err := os.WriteFile(js.filepath, data, 0644); err != nil {
		return fmt.Errorf("failed to save JsonStore file: %v", err)
	}
	return nil
}

// AI generated comment:
// load reads the JSON file and populates the JsonStore instance with its contents
func (js *JsonStore) load() error {
	data, err := os.ReadFile(js.filepath)
	if err != nil {
		return fmt.Errorf("failed to read JsonStore file: %v", err)
	}
	if err := json.Unmarshal(data, &js); err != nil {
		return fmt.Errorf("failed to unmarshal JsonStore: %v", err)
	}
	return nil
}

// AI generated comment:
// Create adds a new chore to the storage
// Accepts a chore.Chore pointer as argument and returns error if chore already exists
func (js *JsonStore) Create(ch domain.Chore) error {
	js.mutex.Lock()
	defer js.mutex.Unlock()
	if err := js.load(); err != nil {
		return fmt.Errorf("failed to load JsonStore: %v", err)
	}

	if _, ok := js.Chores[ch.ID]; ok {
		return fmt.Errorf("chore %v already created", ch.ID)
	}

	js.Chores[ch.ID] = ch

	if err := js.save(); err != nil {
		return fmt.Errorf("failed to save JsonStore: %v", err)
	}
	return nil
}

// AI generated comment:
// Update modifies an existing chore in the storage
// Accepts a chore.Chore pointer as argument and returns error if chore doesn't exist
func (js *JsonStore) Update(ch domain.Chore) error {
	js.mutex.Lock()
	defer js.mutex.Unlock()
	if err := js.load(); err != nil {
		return fmt.Errorf("failed to load JsonStore: %v", err)
	}

	if _, ok := js.Chores[ch.ID]; !ok {
		return fmt.Errorf("chore %v does not exist", ch.ID)
	}
	js.Chores[ch.ID] = ch

	if err := js.save(); err != nil {
		return fmt.Errorf("failed to save JsonStore: %v", err)
	}
	return nil
}

// AI generated comment:
// Read retrieves a chore from storage by its ID
// Accepts integer ID as argument and returns chore pointer or error if not found
func (js *JsonStore) Read(id int64) (domain.Chore, error) {
	js.mutex.Lock()
	defer js.mutex.Unlock()
	if err := js.load(); err != nil {
		return domain.Chore{}, fmt.Errorf("failed to load JsonStore: %v", err)
	}

	ch, ok := js.Chores[id]
	switch ok {
	default:
		return domain.Chore{}, fmt.Errorf("chore %v does not exist", id)
	case true:
		return ch, nil
	}
}

// AI generated comment:
// Delete removes a chore from storage by its ID
// Accepts integer ID as argument and returns error if chore doesn't exist
func (js *JsonStore) Delete(id int64) error {
	js.mutex.Lock()
	defer js.mutex.Unlock()
	if err := js.load(); err != nil {
		return fmt.Errorf("failed to load JsonStore: %v", err)
	}

	if _, ok := js.Chores[id]; !ok {
		return fmt.Errorf("chore %v does not exist", id)
	}

	delete(js.Chores, id)
	if err := js.save(); err != nil {
		return fmt.Errorf("failed to save JsonStore: %v", err)
	}
	return nil
}

// AI generated comment:
// GetAll returns all chores from the storage as a slice of chore pointers
func (js *JsonStore) GetAll() ([]domain.Chore, error) {
	js.mutex.Lock()
	defer js.mutex.Unlock()
	if err := js.load(); err != nil {
		return nil, fmt.Errorf("failed to load JsonStore: %v", err)
	}
	chores := []domain.Chore{}
	for _, v := range js.Chores {
		chores = append(chores, v)
	}
	sortChoresByID(chores)
	return chores, nil
}

func sortChoresByID(chores []domain.Chore) {
	sort.Slice(chores, func(i, j int) bool {
		return chores[i].ID < chores[j].ID
	})
}

// AI generated comment:
// fileExist checks if a file exists at the given path
// Accepts string path as argument and returns boolean indicating existence
func fileExist(path string) bool {
	if _, err := os.Stat(path); err == nil {
		return true
	}
	return false
}

========================================
internal\infrastructure\storage\storage.go
package storage

import (
	"fmt"

	"github.com/Galdoba/choretracker/internal/core/ports"
	"github.com/Galdoba/choretracker/internal/infrastructure/storage/ims"
	"github.com/Galdoba/choretracker/internal/infrastructure/storage/js"
)

type StorageType string

const (
	InMemoryStorage StorageType = "ims"
	JsonStorage     StorageType = "js"
)

func NewStorage(st StorageType, path string) (ports.Storage, error) {
	switch st {
	case InMemoryStorage:
		return ims.NewInMemoryStorage(), nil
	case JsonStorage:
		store, err := js.New(path)
		return store, err
	default:
		return nil, fmt.Errorf("unknown storage type: %v", st)

	}
}

========================================
internal\infrastructure\validator.go
package infrastructure

import (
	"github.com/Galdoba/choretracker/internal/core/dto"
)

type defaultValidator struct{}

func DefaultValidator() *defaultValidator {
	return &defaultValidator{}
}

func (v *defaultValidator) ValidateRequest(req dto.ToServiceRequest) error {
	switch req.Action {
	case dto.Create:
		if err := validateContent(req.Fields); err != nil {
			return err
		}
	case dto.Read, dto.Delete:
		if err := validateIdentity(req.Identity); err != nil {
			return err
		}
	case dto.Update:
		if err := validateIdentity(req.Identity); err != nil {
			return err
		}
		if err := validateContent(req.Fields); err != nil {
			return err
		}

	}
	return nil
}

func validateContent(c dto.ChoreContent) error {

	return nil
}

func validateIdentity(i dto.ChoreIdentity) error {

	return nil
}

========================================
internal\utils\fields.go
package utils

func SetUpdatedField(old string, new *string) string {
	if new == nil {
		return old
	}
	if *new == "" {
		return old
	}
	if *new == "null" {
		return ""
	}
	return *new
}

========================================
internal\utils\logging.go
package utils

import (
	"fmt"

	"github.com/Galdoba/choretracker/internal/core/ports"
)

func LogError(logger ports.Logger, msg string, err error) error {
	logger.Errorf(msg)
	if err == nil {
		return fmt.Errorf("%v", msg)
	}
	return fmt.Errorf("%v: %v", msg, err)
}

========================================
pkg\cronexpr\cronexpr.go
/*!
 * Copyright 2013 Raymond Hill
 *
 * Project: github.com/gorhill/cronexpr
 * File: cronexpr.go
 * Version: 1.0
 * License: pick the one which suits you :
 *   GPL v3 see <https://www.gnu.org/licenses/gpl.html>
 *   APL v2 see <http://www.apache.org/licenses/LICENSE-2.0>
 *
 */

// Package cronexpr parses cron time expressions.
package cronexpr

/******************************************************************************/

import (
	"fmt"
	"sort"
	"time"
)

/******************************************************************************/

// A Expression represents a specific cron time expression as defined at
// <https://github.com/gorhill/cronexpr#implementation>
type Expression struct {
	expression             string
	secondList             []int
	minuteList             []int
	hourList               []int
	daysOfMonth            map[int]bool
	workdaysOfMonth        map[int]bool
	lastDayOfMonth         bool
	lastWorkdayOfMonth     bool
	daysOfMonthRestricted  bool
	actualDaysOfMonthList  []int
	monthList              []int
	daysOfWeek             map[int]bool
	specificWeekDaysOfWeek map[int]bool
	lastWeekDaysOfWeek     map[int]bool
	daysOfWeekRestricted   bool
	yearList               []int
}

/******************************************************************************/

// MustParse returns a new Expression pointer. It expects a well-formed cron
// expression. If a malformed cron expression is supplied, it will `panic`.
// See <https://github.com/gorhill/cronexpr#implementation> for documentation
// about what is a well-formed cron expression from this library's point of
// view.
func MustParse(cronLine string) *Expression {
	expr, err := Parse(cronLine)
	if err != nil {
		panic(err)
	}
	return expr
}

/******************************************************************************/

// Parse returns a new Expression pointer. An error is returned if a malformed
// cron expression is supplied.
// See <https://github.com/gorhill/cronexpr#implementation> for documentation
// about what is a well-formed cron expression from this library's point of
// view.
func Parse(cronLine string) (*Expression, error) {

	// Maybe one of the built-in aliases is being used
	cron := cronNormalizer.Replace(cronLine)

	indices := fieldFinder.FindAllStringIndex(cron, -1)
	fieldCount := len(indices)
	if fieldCount < 5 {
		return nil, fmt.Errorf("missing field(s)")
	}
	// ignore fields beyond 7th
	if fieldCount > 7 {
		fieldCount = 7
	}

	var expr = Expression{}
	var field = 0
	var err error

	// second field (optional)
	if fieldCount == 7 {
		err = expr.secondFieldHandler(cron[indices[field][0]:indices[field][1]])
		if err != nil {
			return nil, err
		}
		field += 1
	} else {
		expr.secondList = []int{0}
	}

	// minute field
	err = expr.minuteFieldHandler(cron[indices[field][0]:indices[field][1]])
	if err != nil {
		return nil, err
	}
	field += 1

	// hour field
	err = expr.hourFieldHandler(cron[indices[field][0]:indices[field][1]])
	if err != nil {
		return nil, err
	}
	field += 1

	// day of month field
	err = expr.domFieldHandler(cron[indices[field][0]:indices[field][1]])
	if err != nil {
		return nil, err
	}
	field += 1

	// month field
	err = expr.monthFieldHandler(cron[indices[field][0]:indices[field][1]])
	if err != nil {
		return nil, err
	}
	field += 1

	// day of week field
	err = expr.dowFieldHandler(cron[indices[field][0]:indices[field][1]])
	if err != nil {
		return nil, err
	}
	field += 1

	// year field
	if field < fieldCount {
		err = expr.yearFieldHandler(cron[indices[field][0]:indices[field][1]])
		if err != nil {
			return nil, err
		}
	} else {
		expr.yearList = yearDescriptor.defaultList
	}

	return &expr, nil
}

/******************************************************************************/

// Next returns the closest time instant immediately following `fromTime` which
// matches the cron expression `expr`.
//
// The `time.Location` of the returned time instant is the same as that of
// `fromTime`.
//
// The zero value of time.Time is returned if no matching time instant exists
// or if a `fromTime` is itself a zero value.
func (expr *Expression) Next(fromTime time.Time) time.Time {
	// Special case
	if fromTime.IsZero() {
		return fromTime
	}

	// Since expr.nextSecond()-expr.nextMonth() expects that the
	// supplied time stamp is a perfect match to the underlying cron
	// expression, and since this function is an entry point where `fromTime`
	// does not necessarily matches the underlying cron expression,
	// we first need to ensure supplied time stamp matches
	// the cron expression. If not, this means the supplied time
	// stamp falls in between matching time stamps, thus we move
	// to closest future matching immediately upon encountering a mismatching
	// time stamp.

	// year
	v := fromTime.Year()
	i := sort.SearchInts(expr.yearList, v)
	if i == len(expr.yearList) {
		return time.Time{}
	}
	if v != expr.yearList[i] {
		return expr.nextYear(fromTime)
	}
	// month
	v = int(fromTime.Month())
	i = sort.SearchInts(expr.monthList, v)
	if i == len(expr.monthList) {
		return expr.nextYear(fromTime)
	}
	if v != expr.monthList[i] {
		return expr.nextMonth(fromTime)
	}

	expr.actualDaysOfMonthList = expr.calculateActualDaysOfMonth(fromTime.Year(), int(fromTime.Month()))
	if len(expr.actualDaysOfMonthList) == 0 {
		return expr.nextMonth(fromTime)
	}

	// day of month
	v = fromTime.Day()
	i = sort.SearchInts(expr.actualDaysOfMonthList, v)
	if i == len(expr.actualDaysOfMonthList) {
		return expr.nextMonth(fromTime)
	}
	if v != expr.actualDaysOfMonthList[i] {
		return expr.nextDayOfMonth(fromTime)
	}
	// hour
	v = fromTime.Hour()
	i = sort.SearchInts(expr.hourList, v)
	if i == len(expr.hourList) {
		return expr.nextDayOfMonth(fromTime)
	}
	if v != expr.hourList[i] {
		return expr.nextHour(fromTime)
	}
	// minute
	v = fromTime.Minute()
	i = sort.SearchInts(expr.minuteList, v)
	if i == len(expr.minuteList) {
		return expr.nextHour(fromTime)
	}
	if v != expr.minuteList[i] {
		return expr.nextMinute(fromTime)
	}
	// second
	v = fromTime.Second()
	i = sort.SearchInts(expr.secondList, v)
	if i == len(expr.secondList) {
		return expr.nextMinute(fromTime)
	}

	// If we reach this point, there is nothing better to do
	// than to move to the next second

	return expr.nextSecond(fromTime)
}

/******************************************************************************/

// NextN returns a slice of `n` closest time instants immediately following
// `fromTime` which match the cron expression `expr`.
//
// The time instants in the returned slice are in chronological ascending order.
// The `time.Location` of the returned time instants is the same as that of
// `fromTime`.
//
// A slice with len between [0-`n`] is returned, that is, if not enough existing
// matching time instants exist, the number of returned entries will be less
// than `n`.
func (expr *Expression) NextN(fromTime time.Time, n uint) []time.Time {
	nextTimes := make([]time.Time, 0, n)
	if n > 0 {
		fromTime = expr.Next(fromTime)
		for {
			if fromTime.IsZero() {
				break
			}
			nextTimes = append(nextTimes, fromTime)
			n -= 1
			if n == 0 {
				break
			}
			fromTime = expr.nextSecond(fromTime)
		}
	}
	return nextTimes
}

========================================
pkg\cronexpr\cronexpr_next.go
/*!
 * Copyright 2013 Raymond Hill
 *
 * Project: github.com/gorhill/cronexpr
 * File: cronexpr_next.go
 * Version: 1.0
 * License: pick the one which suits you :
 *   GPL v3 see <https://www.gnu.org/licenses/gpl.html>
 *   APL v2 see <http://www.apache.org/licenses/LICENSE-2.0>
 *
 */

package cronexpr

/******************************************************************************/

import (
	"sort"
	"time"
)

/******************************************************************************/

var dowNormalizedOffsets = [][]int{
	{1, 8, 15, 22, 29},
	{2, 9, 16, 23, 30},
	{3, 10, 17, 24, 31},
	{4, 11, 18, 25},
	{5, 12, 19, 26},
	{6, 13, 20, 27},
	{7, 14, 21, 28},
}

/******************************************************************************/

func (expr *Expression) nextYear(t time.Time) time.Time {
	// Find index at which item in list is greater or equal to
	// candidate year
	i := sort.SearchInts(expr.yearList, t.Year()+1)
	if i == len(expr.yearList) {
		return time.Time{}
	}
	// Year changed, need to recalculate actual days of month
	expr.actualDaysOfMonthList = expr.calculateActualDaysOfMonth(expr.yearList[i], expr.monthList[0])
	if len(expr.actualDaysOfMonthList) == 0 {
		return expr.nextMonth(time.Date(
			expr.yearList[i],
			time.Month(expr.monthList[0]),
			1,
			expr.hourList[0],
			expr.minuteList[0],
			expr.secondList[0],
			0,
			t.Location()))
	}
	return time.Date(
		expr.yearList[i],
		time.Month(expr.monthList[0]),
		expr.actualDaysOfMonthList[0],
		expr.hourList[0],
		expr.minuteList[0],
		expr.secondList[0],
		0,
		t.Location())
}

/******************************************************************************/

func (expr *Expression) nextMonth(t time.Time) time.Time {
	// Find index at which item in list is greater or equal to
	// candidate month
	i := sort.SearchInts(expr.monthList, int(t.Month())+1)
	if i == len(expr.monthList) {
		return expr.nextYear(t)
	}
	// Month changed, need to recalculate actual days of month
	expr.actualDaysOfMonthList = expr.calculateActualDaysOfMonth(t.Year(), expr.monthList[i])
	if len(expr.actualDaysOfMonthList) == 0 {
		return expr.nextMonth(time.Date(
			t.Year(),
			time.Month(expr.monthList[i]),
			1,
			expr.hourList[0],
			expr.minuteList[0],
			expr.secondList[0],
			0,
			t.Location()))
	}

	return time.Date(
		t.Year(),
		time.Month(expr.monthList[i]),
		expr.actualDaysOfMonthList[0],
		expr.hourList[0],
		expr.minuteList[0],
		expr.secondList[0],
		0,
		t.Location())
}

/******************************************************************************/

func (expr *Expression) nextDayOfMonth(t time.Time) time.Time {
	// Find index at which item in list is greater or equal to
	// candidate day of month
	i := sort.SearchInts(expr.actualDaysOfMonthList, t.Day()+1)
	if i == len(expr.actualDaysOfMonthList) {
		return expr.nextMonth(t)
	}

	return time.Date(
		t.Year(),
		t.Month(),
		expr.actualDaysOfMonthList[i],
		expr.hourList[0],
		expr.minuteList[0],
		expr.secondList[0],
		0,
		t.Location())
}

/******************************************************************************/

func (expr *Expression) nextHour(t time.Time) time.Time {
	// Find index at which item in list is greater or equal to
	// candidate hour
	i := sort.SearchInts(expr.hourList, t.Hour()+1)
	if i == len(expr.hourList) {
		return expr.nextDayOfMonth(t)
	}

	return time.Date(
		t.Year(),
		t.Month(),
		t.Day(),
		expr.hourList[i],
		expr.minuteList[0],
		expr.secondList[0],
		0,
		t.Location())
}

/******************************************************************************/

func (expr *Expression) nextMinute(t time.Time) time.Time {
	// Find index at which item in list is greater or equal to
	// candidate minute
	i := sort.SearchInts(expr.minuteList, t.Minute()+1)
	if i == len(expr.minuteList) {
		return expr.nextHour(t)
	}

	return time.Date(
		t.Year(),
		t.Month(),
		t.Day(),
		t.Hour(),
		expr.minuteList[i],
		expr.secondList[0],
		0,
		t.Location())
}

/******************************************************************************/

func (expr *Expression) nextSecond(t time.Time) time.Time {
	// nextSecond() assumes all other fields are exactly matched
	// to the cron expression

	// Find index at which item in list is greater or equal to
	// candidate second
	i := sort.SearchInts(expr.secondList, t.Second()+1)
	if i == len(expr.secondList) {
		return expr.nextMinute(t)
	}

	return time.Date(
		t.Year(),
		t.Month(),
		t.Day(),
		t.Hour(),
		t.Minute(),
		expr.secondList[i],
		0,
		t.Location())
}

/******************************************************************************/

func (expr *Expression) calculateActualDaysOfMonth(year, month int) []int {
	actualDaysOfMonthMap := make(map[int]bool)
	firstDayOfMonth := time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.UTC)
	lastDayOfMonth := firstDayOfMonth.AddDate(0, 1, -1)

	// As per crontab man page (http://linux.die.net/man/5/crontab#):
	//  "The day of a command's execution can be specified by two
	//  "fields - day of month, and day of week. If both fields are
	//  "restricted (ie, aren't *), the command will be run when
	//  "either field matches the current time"

	// If both fields are not restricted, all days of the month are a hit
	if expr.daysOfMonthRestricted == false && expr.daysOfWeekRestricted == false {
		return genericDefaultList[1 : lastDayOfMonth.Day()+1]
	}

	// day-of-month != `*`
	if expr.daysOfMonthRestricted {
		// Last day of month
		if expr.lastDayOfMonth {
			actualDaysOfMonthMap[lastDayOfMonth.Day()] = true
		}
		// Last work day of month
		if expr.lastWorkdayOfMonth {
			actualDaysOfMonthMap[workdayOfMonth(lastDayOfMonth, lastDayOfMonth)] = true
		}
		// Days of month
		for v := range expr.daysOfMonth {
			// Ignore days beyond end of month
			if v <= lastDayOfMonth.Day() {
				actualDaysOfMonthMap[v] = true
			}
		}
		// Work days of month
		// As per Wikipedia: month boundaries are not crossed.
		for v := range expr.workdaysOfMonth {
			// Ignore days beyond end of month
			if v <= lastDayOfMonth.Day() {
				actualDaysOfMonthMap[workdayOfMonth(firstDayOfMonth.AddDate(0, 0, v-1), lastDayOfMonth)] = true
			}
		}
	}

	// day-of-week != `*`
	if expr.daysOfWeekRestricted {
		// How far first sunday is from first day of month
		offset := 7 - int(firstDayOfMonth.Weekday())
		// days of week
		//  offset : (7 - day_of_week_of_1st_day_of_month)
		//  target : 1 + (7 * week_of_month) + (offset + day_of_week) % 7
		for v := range expr.daysOfWeek {
			w := dowNormalizedOffsets[(offset+v)%7]
			actualDaysOfMonthMap[w[0]] = true
			actualDaysOfMonthMap[w[1]] = true
			actualDaysOfMonthMap[w[2]] = true
			actualDaysOfMonthMap[w[3]] = true
			if len(w) > 4 && w[4] <= lastDayOfMonth.Day() {
				actualDaysOfMonthMap[w[4]] = true
			}
		}
		// days of week of specific week in the month
		//  offset : (7 - day_of_week_of_1st_day_of_month)
		//  target : 1 + (7 * week_of_month) + (offset + day_of_week) % 7
		for v := range expr.specificWeekDaysOfWeek {
			v = 1 + 7*(v/7) + (offset+v)%7
			if v <= lastDayOfMonth.Day() {
				actualDaysOfMonthMap[v] = true
			}
		}
		// Last days of week of the month
		lastWeekOrigin := firstDayOfMonth.AddDate(0, 1, -7)
		offset = 7 - int(lastWeekOrigin.Weekday())
		for v := range expr.lastWeekDaysOfWeek {
			v = lastWeekOrigin.Day() + (offset+v)%7
			if v <= lastDayOfMonth.Day() {
				actualDaysOfMonthMap[v] = true
			}
		}
	}

	return toList(actualDaysOfMonthMap)
}

func workdayOfMonth(targetDom, lastDom time.Time) int {
	// If saturday, then friday
	// If sunday, then monday
	dom := targetDom.Day()
	dow := targetDom.Weekday()
	if dow == time.Saturday {
		if dom > 1 {
			dom -= 1
		} else {
			dom += 2
		}
	} else if dow == time.Sunday {
		if dom < lastDom.Day() {
			dom += 1
		} else {
			dom -= 2
		}
	}
	return dom
}

========================================
pkg\cronexpr\cronexpr_parse.go
/*!
 * Copyright 2013 Raymond Hill
 *
 * Project: github.com/gorhill/cronexpr
 * File: cronexpr_parse.go
 * Version: 1.0
 * License: pick the one which suits you best:
 *   GPL v3 see <https://www.gnu.org/licenses/gpl.html>
 *   APL v2 see <http://www.apache.org/licenses/LICENSE-2.0>
 *
 */

package cronexpr

/******************************************************************************/

import (
	"fmt"
	"regexp"
	"sort"
	"strings"
	"sync"
)

/******************************************************************************/

var (
	genericDefaultList = []int{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
		40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
		50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
	}
	yearDefaultList = []int{
		1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979,
		1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989,
		1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
		2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
		2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019,
		2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029,
		2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039,
		2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049,
		2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059,
		2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069,
		2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079,
		2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089,
		2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099,
	}
)

/******************************************************************************/

var (
	numberTokens = map[string]int{
		"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9,
		"00": 0, "01": 1, "02": 2, "03": 3, "04": 4, "05": 5, "06": 6, "07": 7, "08": 8, "09": 9,
		"10": 10, "11": 11, "12": 12, "13": 13, "14": 14, "15": 15, "16": 16, "17": 17, "18": 18, "19": 19,
		"20": 20, "21": 21, "22": 22, "23": 23, "24": 24, "25": 25, "26": 26, "27": 27, "28": 28, "29": 29,
		"30": 30, "31": 31, "32": 32, "33": 33, "34": 34, "35": 35, "36": 36, "37": 37, "38": 38, "39": 39,
		"40": 40, "41": 41, "42": 42, "43": 43, "44": 44, "45": 45, "46": 46, "47": 47, "48": 48, "49": 49,
		"50": 50, "51": 51, "52": 52, "53": 53, "54": 54, "55": 55, "56": 56, "57": 57, "58": 58, "59": 59,
		"1970": 1970, "1971": 1971, "1972": 1972, "1973": 1973, "1974": 1974, "1975": 1975, "1976": 1976, "1977": 1977, "1978": 1978, "1979": 1979,
		"1980": 1980, "1981": 1981, "1982": 1982, "1983": 1983, "1984": 1984, "1985": 1985, "1986": 1986, "1987": 1987, "1988": 1988, "1989": 1989,
		"1990": 1990, "1991": 1991, "1992": 1992, "1993": 1993, "1994": 1994, "1995": 1995, "1996": 1996, "1997": 1997, "1998": 1998, "1999": 1999,
		"2000": 2000, "2001": 2001, "2002": 2002, "2003": 2003, "2004": 2004, "2005": 2005, "2006": 2006, "2007": 2007, "2008": 2008, "2009": 2009,
		"2010": 2010, "2011": 2011, "2012": 2012, "2013": 2013, "2014": 2014, "2015": 2015, "2016": 2016, "2017": 2017, "2018": 2018, "2019": 2019,
		"2020": 2020, "2021": 2021, "2022": 2022, "2023": 2023, "2024": 2024, "2025": 2025, "2026": 2026, "2027": 2027, "2028": 2028, "2029": 2029,
		"2030": 2030, "2031": 2031, "2032": 2032, "2033": 2033, "2034": 2034, "2035": 2035, "2036": 2036, "2037": 2037, "2038": 2038, "2039": 2039,
		"2040": 2040, "2041": 2041, "2042": 2042, "2043": 2043, "2044": 2044, "2045": 2045, "2046": 2046, "2047": 2047, "2048": 2048, "2049": 2049,
		"2050": 2050, "2051": 2051, "2052": 2052, "2053": 2053, "2054": 2054, "2055": 2055, "2056": 2056, "2057": 2057, "2058": 2058, "2059": 2059,
		"2060": 2060, "2061": 2061, "2062": 2062, "2063": 2063, "2064": 2064, "2065": 2065, "2066": 2066, "2067": 2067, "2068": 2068, "2069": 2069,
		"2070": 2070, "2071": 2071, "2072": 2072, "2073": 2073, "2074": 2074, "2075": 2075, "2076": 2076, "2077": 2077, "2078": 2078, "2079": 2079,
		"2080": 2080, "2081": 2081, "2082": 2082, "2083": 2083, "2084": 2084, "2085": 2085, "2086": 2086, "2087": 2087, "2088": 2088, "2089": 2089,
		"2090": 2090, "2091": 2091, "2092": 2092, "2093": 2093, "2094": 2094, "2095": 2095, "2096": 2096, "2097": 2097, "2098": 2098, "2099": 2099,
	}
	monthTokens = map[string]int{
		`1`: 1, `jan`: 1, `january`: 1,
		`2`: 2, `feb`: 2, `february`: 2,
		`3`: 3, `mar`: 3, `march`: 3,
		`4`: 4, `apr`: 4, `april`: 4,
		`5`: 5, `may`: 5,
		`6`: 6, `jun`: 6, `june`: 6,
		`7`: 7, `jul`: 7, `july`: 7,
		`8`: 8, `aug`: 8, `august`: 8,
		`9`: 9, `sep`: 9, `september`: 9,
		`10`: 10, `oct`: 10, `october`: 10,
		`11`: 11, `nov`: 11, `november`: 11,
		`12`: 12, `dec`: 12, `december`: 12,
	}
	dowTokens = map[string]int{
		`0`: 0, `sun`: 0, `sunday`: 0,
		`1`: 1, `mon`: 1, `monday`: 1,
		`2`: 2, `tue`: 2, `tuesday`: 2,
		`3`: 3, `wed`: 3, `wednesday`: 3,
		`4`: 4, `thu`: 4, `thursday`: 4,
		`5`: 5, `fri`: 5, `friday`: 5,
		`6`: 6, `sat`: 6, `saturday`: 6,
		`7`: 0,
	}
)

/******************************************************************************/

func atoi(s string) int {
	return numberTokens[s]
}

type fieldDescriptor struct {
	name         string
	min, max     int
	defaultList  []int
	valuePattern string
	atoi         func(string) int
}

var (
	secondDescriptor = fieldDescriptor{
		name:         "second",
		min:          0,
		max:          59,
		defaultList:  genericDefaultList[0:60],
		valuePattern: `0?[0-9]|[1-5][0-9]`,
		atoi:         atoi,
	}
	minuteDescriptor = fieldDescriptor{
		name:         "minute",
		min:          0,
		max:          59,
		defaultList:  genericDefaultList[0:60],
		valuePattern: `0?[0-9]|[1-5][0-9]`,
		atoi:         atoi,
	}
	hourDescriptor = fieldDescriptor{
		name:         "hour",
		min:          0,
		max:          23,
		defaultList:  genericDefaultList[0:24],
		valuePattern: `0?[0-9]|1[0-9]|2[0-3]`,
		atoi:         atoi,
	}
	domDescriptor = fieldDescriptor{
		name:         "day-of-month",
		min:          1,
		max:          31,
		defaultList:  genericDefaultList[1:32],
		valuePattern: `0?[1-9]|[12][0-9]|3[01]`,
		atoi:         atoi,
	}
	monthDescriptor = fieldDescriptor{
		name:         "month",
		min:          1,
		max:          12,
		defaultList:  genericDefaultList[1:13],
		valuePattern: `0?[1-9]|1[012]|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|january|february|march|april|march|april|june|july|august|september|october|november|december`,
		atoi: func(s string) int {
			return monthTokens[s]
		},
	}
	dowDescriptor = fieldDescriptor{
		name:         "day-of-week",
		min:          0,
		max:          6,
		defaultList:  genericDefaultList[0:7],
		valuePattern: `0?[0-7]|sun|mon|tue|wed|thu|fri|sat|sunday|monday|tuesday|wednesday|thursday|friday|saturday`,
		atoi: func(s string) int {
			return dowTokens[s]
		},
	}
	yearDescriptor = fieldDescriptor{
		name:         "year",
		min:          1970,
		max:          2099,
		defaultList:  yearDefaultList[:],
		valuePattern: `19[789][0-9]|20[0-9]{2}`,
		atoi:         atoi,
	}
)

/******************************************************************************/

var (
	layoutWildcard            = `^\*$|^\?$`
	layoutValue               = `^(%value%)$`
	layoutRange               = `^(%value%)-(%value%)$`
	layoutWildcardAndInterval = `^\*/(\d+)$`
	layoutValueAndInterval    = `^(%value%)/(\d+)$`
	layoutRangeAndInterval    = `^(%value%)-(%value%)/(\d+)$`
	layoutLastDom             = `^l$`
	layoutWorkdom             = `^(%value%)w$`
	layoutLastWorkdom         = `^lw$`
	layoutDowOfLastWeek       = `^(%value%)l$`
	layoutDowOfSpecificWeek   = `^(%value%)#([1-5])$`
	fieldFinder               = regexp.MustCompile(`\S+`)
	entryFinder               = regexp.MustCompile(`[^,]+`)
	layoutRegexp              = make(map[string]*regexp.Regexp)
	layoutRegexpLock          sync.Mutex
)

/******************************************************************************/

var cronNormalizer = strings.NewReplacer(
	"@yearly", "0 0 0 1 1 * *",
	"@annually", "0 0 0 1 1 * *",
	"@monthly", "0 0 0 1 * * *",
	"@weekly", "0 0 0 * * 0 *",
	"@daily", "0 0 0 * * * *",
	"@hourly", "0 0 * * * * *")

/******************************************************************************/

func (expr *Expression) secondFieldHandler(s string) error {
	var err error
	expr.secondList, err = genericFieldHandler(s, secondDescriptor)
	return err
}

/******************************************************************************/

func (expr *Expression) minuteFieldHandler(s string) error {
	var err error
	expr.minuteList, err = genericFieldHandler(s, minuteDescriptor)
	return err
}

/******************************************************************************/

func (expr *Expression) hourFieldHandler(s string) error {
	var err error
	expr.hourList, err = genericFieldHandler(s, hourDescriptor)
	return err
}

/******************************************************************************/

func (expr *Expression) monthFieldHandler(s string) error {
	var err error
	expr.monthList, err = genericFieldHandler(s, monthDescriptor)
	return err
}

/******************************************************************************/

func (expr *Expression) yearFieldHandler(s string) error {
	var err error
	expr.yearList, err = genericFieldHandler(s, yearDescriptor)
	return err
}

/******************************************************************************/

const (
	none = 0
	one  = 1
	span = 2
	all  = 3
)

type cronDirective struct {
	kind  int
	first int
	last  int
	step  int
	sbeg  int
	send  int
}

func genericFieldHandler(s string, desc fieldDescriptor) ([]int, error) {
	directives, err := genericFieldParse(s, desc)
	if err != nil {
		return nil, err
	}
	values := make(map[int]bool)
	for _, directive := range directives {
		switch directive.kind {
		case none:
			return nil, fmt.Errorf("syntax error in %s field: '%s'", desc.name, s[directive.sbeg:directive.send])
		case one:
			populateOne(values, directive.first)
		case span:
			populateMany(values, directive.first, directive.last, directive.step)
		case all:
			return desc.defaultList, nil
		}
	}
	return toList(values), nil
}

func (expr *Expression) dowFieldHandler(s string) error {
	expr.daysOfWeekRestricted = true
	expr.daysOfWeek = make(map[int]bool)
	expr.lastWeekDaysOfWeek = make(map[int]bool)
	expr.specificWeekDaysOfWeek = make(map[int]bool)

	directives, err := genericFieldParse(s, dowDescriptor)
	if err != nil {
		return err
	}

	for _, directive := range directives {
		switch directive.kind {
		case none:
			sdirective := s[directive.sbeg:directive.send]
			snormal := strings.ToLower(sdirective)
			// `5L`
			pairs := makeLayoutRegexp(layoutDowOfLastWeek, dowDescriptor.valuePattern).FindStringSubmatchIndex(snormal)
			if len(pairs) > 0 {
				populateOne(expr.lastWeekDaysOfWeek, dowDescriptor.atoi(snormal[pairs[2]:pairs[3]]))
			} else {
				// `5#3`
				pairs := makeLayoutRegexp(layoutDowOfSpecificWeek, dowDescriptor.valuePattern).FindStringSubmatchIndex(snormal)
				if len(pairs) > 0 {
					populateOne(expr.specificWeekDaysOfWeek, (dowDescriptor.atoi(snormal[pairs[4]:pairs[5]])-1)*7+(dowDescriptor.atoi(snormal[pairs[2]:pairs[3]])%7))
				} else {
					return fmt.Errorf("syntax error in day-of-week field: '%s'", sdirective)
				}
			}
		case one:
			populateOne(expr.daysOfWeek, directive.first)
		case span:
			populateMany(expr.daysOfWeek, directive.first, directive.last, directive.step)
		case all:
			populateMany(expr.daysOfWeek, directive.first, directive.last, directive.step)
			expr.daysOfWeekRestricted = false
		}
	}
	return nil
}

func (expr *Expression) domFieldHandler(s string) error {
	expr.daysOfMonthRestricted = true
	expr.lastDayOfMonth = false
	expr.lastWorkdayOfMonth = false
	expr.daysOfMonth = make(map[int]bool)     // days of month map
	expr.workdaysOfMonth = make(map[int]bool) // work days of month map

	directives, err := genericFieldParse(s, domDescriptor)
	if err != nil {
		return err
	}

	for _, directive := range directives {
		switch directive.kind {
		case none:
			sdirective := s[directive.sbeg:directive.send]
			snormal := strings.ToLower(sdirective)
			// `L`
			if makeLayoutRegexp(layoutLastDom, domDescriptor.valuePattern).MatchString(snormal) {
				expr.lastDayOfMonth = true
			} else {
				// `LW`
				if makeLayoutRegexp(layoutLastWorkdom, domDescriptor.valuePattern).MatchString(snormal) {
					expr.lastWorkdayOfMonth = true
				} else {
					// `15W`
					pairs := makeLayoutRegexp(layoutWorkdom, domDescriptor.valuePattern).FindStringSubmatchIndex(snormal)
					if len(pairs) > 0 {
						populateOne(expr.workdaysOfMonth, domDescriptor.atoi(snormal[pairs[2]:pairs[3]]))
					} else {
						return fmt.Errorf("syntax error in day-of-month field: '%s'", sdirective)
					}
				}
			}
		case one:
			populateOne(expr.daysOfMonth, directive.first)
		case span:
			populateMany(expr.daysOfMonth, directive.first, directive.last, directive.step)
		case all:
			populateMany(expr.daysOfMonth, directive.first, directive.last, directive.step)
			expr.daysOfMonthRestricted = false
		}
	}
	return nil
}

/******************************************************************************/

func populateOne(values map[int]bool, v int) {
	values[v] = true
}

func populateMany(values map[int]bool, min, max, step int) {
	for i := min; i <= max; i += step {
		values[i] = true
	}
}

func toList(set map[int]bool) []int {
	list := make([]int, len(set))
	i := 0
	for k := range set {
		list[i] = k
		i += 1
	}
	sort.Ints(list)
	return list
}

/******************************************************************************/

func genericFieldParse(s string, desc fieldDescriptor) ([]*cronDirective, error) {
	// At least one entry must be present
	indices := entryFinder.FindAllStringIndex(s, -1)
	if len(indices) == 0 {
		return nil, fmt.Errorf("%s field: missing directive", desc.name)
	}

	directives := make([]*cronDirective, 0, len(indices))

	for i := range indices {
		directive := cronDirective{
			sbeg: indices[i][0],
			send: indices[i][1],
		}
		snormal := strings.ToLower(s[indices[i][0]:indices[i][1]])

		// `*`
		if makeLayoutRegexp(layoutWildcard, desc.valuePattern).MatchString(snormal) {
			directive.kind = all
			directive.first = desc.min
			directive.last = desc.max
			directive.step = 1
			directives = append(directives, &directive)
			continue
		}
		// `5`
		if makeLayoutRegexp(layoutValue, desc.valuePattern).MatchString(snormal) {
			directive.kind = one
			directive.first = desc.atoi(snormal)
			directives = append(directives, &directive)
			continue
		}
		// `5-20`
		pairs := makeLayoutRegexp(layoutRange, desc.valuePattern).FindStringSubmatchIndex(snormal)
		if len(pairs) > 0 {
			directive.kind = span
			directive.first = desc.atoi(snormal[pairs[2]:pairs[3]])
			directive.last = desc.atoi(snormal[pairs[4]:pairs[5]])
			directive.step = 1
			directives = append(directives, &directive)
			continue
		}
		// `*/2`
		pairs = makeLayoutRegexp(layoutWildcardAndInterval, desc.valuePattern).FindStringSubmatchIndex(snormal)
		if len(pairs) > 0 {
			directive.kind = span
			directive.first = desc.min
			directive.last = desc.max
			directive.step = atoi(snormal[pairs[2]:pairs[3]])
			if directive.step < 1 || directive.step > desc.max {
				return nil, fmt.Errorf("invalid interval %s", snormal)
			}
			directives = append(directives, &directive)
			continue
		}
		// `5/2`
		pairs = makeLayoutRegexp(layoutValueAndInterval, desc.valuePattern).FindStringSubmatchIndex(snormal)
		if len(pairs) > 0 {
			directive.kind = span
			directive.first = desc.atoi(snormal[pairs[2]:pairs[3]])
			directive.last = desc.max
			directive.step = atoi(snormal[pairs[4]:pairs[5]])
			if directive.step < 1 || directive.step > desc.max {
				return nil, fmt.Errorf("invalid interval %s", snormal)
			}
			directives = append(directives, &directive)
			continue
		}
		// `5-20/2`
		pairs = makeLayoutRegexp(layoutRangeAndInterval, desc.valuePattern).FindStringSubmatchIndex(snormal)
		if len(pairs) > 0 {
			directive.kind = span
			directive.first = desc.atoi(snormal[pairs[2]:pairs[3]])
			directive.last = desc.atoi(snormal[pairs[4]:pairs[5]])
			directive.step = atoi(snormal[pairs[6]:pairs[7]])
			if directive.step < 1 || directive.step > desc.max {
				return nil, fmt.Errorf("invalid interval %s", snormal)
			}
			directives = append(directives, &directive)
			continue
		}
		// No behavior for this one, let caller deal with it
		directive.kind = none
		directives = append(directives, &directive)
	}
	return directives, nil
}

/******************************************************************************/

func makeLayoutRegexp(layout, value string) *regexp.Regexp {
	layoutRegexpLock.Lock()
	defer layoutRegexpLock.Unlock()

	layout = strings.Replace(layout, `%value%`, value, -1)
	re := layoutRegexp[layout]
	if re == nil {
		re = regexp.MustCompile(layout)
		layoutRegexp[layout] = re
	}
	return re
}

========================================
pkg\cronexpr\cronexpr_test.go
/*!
 * Copyright 2013 Raymond Hill
 *
 * Project: github.com/gorhill/cronexpr
 * File: cronexpr_test.go
 * Version: 1.0
 * License: pick the one which suits you best:
 *   GPL v3 see <https://www.gnu.org/licenses/gpl.html>
 *   APL v2 see <http://www.apache.org/licenses/LICENSE-2.0>
 *
 */

package cronexpr

/******************************************************************************/

import (
	"testing"
	"time"
)

/******************************************************************************/

type crontimes struct {
	from string
	next string
}

type crontest struct {
	expr   string
	layout string
	times  []crontimes
}

var crontests = []crontest{
	// Seconds
	{
		"* * * * * * *",
		"2006-01-02 15:04:05",
		[]crontimes{
			{"2013-01-01 00:00:00", "2013-01-01 00:00:01"},
			{"2013-01-01 00:00:59", "2013-01-01 00:01:00"},
			{"2013-01-01 00:59:59", "2013-01-01 01:00:00"},
			{"2013-01-01 23:59:59", "2013-01-02 00:00:00"},
			{"2013-02-28 23:59:59", "2013-03-01 00:00:00"},
			{"2016-02-28 23:59:59", "2016-02-29 00:00:00"},
			{"2012-12-31 23:59:59", "2013-01-01 00:00:00"},
		},
	},

	// every 5 Second
	{
		"*/5 * * * * * *",
		"2006-01-02 15:04:05",
		[]crontimes{
			{"2013-01-01 00:00:00", "2013-01-01 00:00:05"},
			{"2013-01-01 00:00:59", "2013-01-01 00:01:00"},
			{"2013-01-01 00:59:59", "2013-01-01 01:00:00"},
			{"2013-01-01 23:59:59", "2013-01-02 00:00:00"},
			{"2013-02-28 23:59:59", "2013-03-01 00:00:00"},
			{"2016-02-28 23:59:59", "2016-02-29 00:00:00"},
			{"2012-12-31 23:59:59", "2013-01-01 00:00:00"},
		},
	},

	// Minutes
	{
		"* * * * *",
		"2006-01-02 15:04:05",
		[]crontimes{
			{"2013-01-01 00:00:00", "2013-01-01 00:01:00"},
			{"2013-01-01 00:00:59", "2013-01-01 00:01:00"},
			{"2013-01-01 00:59:00", "2013-01-01 01:00:00"},
			{"2013-01-01 23:59:00", "2013-01-02 00:00:00"},
			{"2013-02-28 23:59:00", "2013-03-01 00:00:00"},
			{"2016-02-28 23:59:00", "2016-02-29 00:00:00"},
			{"2012-12-31 23:59:00", "2013-01-01 00:00:00"},
		},
	},

	// Minutes with interval
	{
		"17-43/5 * * * *",
		"2006-01-02 15:04:05",
		[]crontimes{
			{"2013-01-01 00:00:00", "2013-01-01 00:17:00"},
			{"2013-01-01 00:16:59", "2013-01-01 00:17:00"},
			{"2013-01-01 00:30:00", "2013-01-01 00:32:00"},
			{"2013-01-01 00:50:00", "2013-01-01 01:17:00"},
			{"2013-01-01 23:50:00", "2013-01-02 00:17:00"},
			{"2013-02-28 23:50:00", "2013-03-01 00:17:00"},
			{"2016-02-28 23:50:00", "2016-02-29 00:17:00"},
			{"2012-12-31 23:50:00", "2013-01-01 00:17:00"},
		},
	},

	// Minutes interval, list
	{
		"15-30/4,55 * * * *",
		"2006-01-02 15:04:05",
		[]crontimes{
			{"2013-01-01 00:00:00", "2013-01-01 00:15:00"},
			{"2013-01-01 00:16:00", "2013-01-01 00:19:00"},
			{"2013-01-01 00:30:00", "2013-01-01 00:55:00"},
			{"2013-01-01 00:55:00", "2013-01-01 01:15:00"},
			{"2013-01-01 23:55:00", "2013-01-02 00:15:00"},
			{"2013-02-28 23:55:00", "2013-03-01 00:15:00"},
			{"2016-02-28 23:55:00", "2016-02-29 00:15:00"},
			{"2012-12-31 23:54:00", "2012-12-31 23:55:00"},
			{"2012-12-31 23:55:00", "2013-01-01 00:15:00"},
		},
	},

	// Days of week
	{
		"0 0 * * MON",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-01-01 00:00:00", "Mon 2013-01-07 00:00"},
			{"2013-01-28 00:00:00", "Mon 2013-02-04 00:00"},
			{"2013-12-30 00:30:00", "Mon 2014-01-06 00:00"},
		},
	},
	{
		"0 0 * * friday",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-01-01 00:00:00", "Fri 2013-01-04 00:00"},
			{"2013-01-28 00:00:00", "Fri 2013-02-01 00:00"},
			{"2013-12-30 00:30:00", "Fri 2014-01-03 00:00"},
		},
	},
	{
		"0 0 * * 6,7",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-01-01 00:00:00", "Sat 2013-01-05 00:00"},
			{"2013-01-28 00:00:00", "Sat 2013-02-02 00:00"},
			{"2013-12-30 00:30:00", "Sat 2014-01-04 00:00"},
		},
	},

	// Specific days of week
	{
		"0 0 * * 6#5",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-09-02 00:00:00", "Sat 2013-11-30 00:00"},
		},
	},

	// Work day of month
	{
		"0 0 14W * *",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-03-31 00:00:00", "Mon 2013-04-15 00:00"},
			{"2013-08-31 00:00:00", "Fri 2013-09-13 00:00"},
		},
	},

	// Work day of month -- end of month
	{
		"0 0 30W * *",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-03-02 00:00:00", "Fri 2013-03-29 00:00"},
			{"2013-06-02 00:00:00", "Fri 2013-06-28 00:00"},
			{"2013-09-02 00:00:00", "Mon 2013-09-30 00:00"},
			{"2013-11-02 00:00:00", "Fri 2013-11-29 00:00"},
		},
	},

	// Last day of month
	{
		"0 0 L * *",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-09-02 00:00:00", "Mon 2013-09-30 00:00"},
			{"2014-01-01 00:00:00", "Fri 2014-01-31 00:00"},
			{"2014-02-01 00:00:00", "Fri 2014-02-28 00:00"},
			{"2016-02-15 00:00:00", "Mon 2016-02-29 00:00"},
		},
	},

	// Last work day of month
	{
		"0 0 LW * *",
		"Mon 2006-01-02 15:04",
		[]crontimes{
			{"2013-09-02 00:00:00", "Mon 2013-09-30 00:00"},
			{"2013-11-02 00:00:00", "Fri 2013-11-29 00:00"},
			{"2014-08-15 00:00:00", "Fri 2014-08-29 00:00"},
		},
	},

	// TODO: more tests
}

func TestExpressions(t *testing.T) {
	for _, test := range crontests {
		for _, times := range test.times {
			from, _ := time.Parse("2006-01-02 15:04:05", times.from)
			expr, err := Parse(test.expr)
			if err != nil {
				t.Errorf(`Parse("%s") returned "%s"`, test.expr, err.Error())
			}
			next := expr.Next(from)
			nextstr := next.Format(test.layout)
			if nextstr != times.next {
				t.Errorf(`("%s").Next("%s") = "%s", got "%s"`, test.expr, times.from, times.next, nextstr)
			}
		}
	}
}

/******************************************************************************/

func TestZero(t *testing.T) {
	from, _ := time.Parse("2006-01-02", "2013-08-31")
	next := MustParse("* * * * * 1980").Next(from)
	if next.IsZero() == false {
		t.Error(`("* * * * * 1980").Next("2013-08-31").IsZero() returned 'false', expected 'true'`)
	}

	next = MustParse("* * * * * 2050").Next(from)
	if next.IsZero() == true {
		t.Error(`("* * * * * 2050").Next("2013-08-31").IsZero() returned 'true', expected 'false'`)
	}

	next = MustParse("* * * * * 2099").Next(time.Time{})
	if next.IsZero() == false {
		t.Error(`("* * * * * 2014").Next(time.Time{}).IsZero() returned 'true', expected 'false'`)
	}
}

/******************************************************************************/

func TestNextN(t *testing.T) {
	expected := []string{
		"Sat, 30 Nov 2013 00:00:00",
		"Sat, 29 Mar 2014 00:00:00",
		"Sat, 31 May 2014 00:00:00",
		"Sat, 30 Aug 2014 00:00:00",
		"Sat, 29 Nov 2014 00:00:00",
	}
	from, _ := time.Parse("2006-01-02 15:04:05", "2013-09-02 08:44:30")
	result := MustParse("0 0 * * 6#5").NextN(from, uint(len(expected)))
	if len(result) != len(expected) {
		t.Errorf(`MustParse("0 0 * * 6#5").NextN("2013-09-02 08:44:30", 5):\n"`)
		t.Errorf(`  Expected %d returned time values but got %d instead`, len(expected), len(result))
	}
	for i, next := range result {
		nextStr := next.Format("Mon, 2 Jan 2006 15:04:15")
		if nextStr != expected[i] {
			t.Errorf(`MustParse("0 0 * * 6#5").NextN("2013-09-02 08:44:30", 5):\n"`)
			t.Errorf(`  result[%d]: expected "%s" but got "%s"`, i, expected[i], nextStr)
		}
	}
}

func TestNextN_every5min(t *testing.T) {
	expected := []string{
		"Mon, 2 Sep 2013 08:45:00",
		"Mon, 2 Sep 2013 08:50:00",
		"Mon, 2 Sep 2013 08:55:00",
		"Mon, 2 Sep 2013 09:00:00",
		"Mon, 2 Sep 2013 09:05:00",
	}
	from, _ := time.Parse("2006-01-02 15:04:05", "2013-09-02 08:44:32")
	result := MustParse("*/5 * * * *").NextN(from, uint(len(expected)))
	if len(result) != len(expected) {
		t.Errorf(`MustParse("*/5 * * * *").NextN("2013-09-02 08:44:30", 5):\n"`)
		t.Errorf(`  Expected %d returned time values but got %d instead`, len(expected), len(result))
	}
	for i, next := range result {
		nextStr := next.Format("Mon, 2 Jan 2006 15:04:05")
		if nextStr != expected[i] {
			t.Errorf(`MustParse("*/5 * * * *").NextN("2013-09-02 08:44:30", 5):\n"`)
			t.Errorf(`  result[%d]: expected "%s" but got "%s"`, i, expected[i], nextStr)
		}
	}
}

// Issue: https://github.com/gorhill/cronexpr/issues/16
func TestInterval_Interval60Issue(t *testing.T) {
	_, err := Parse("*/60 * * * * *")
	if err == nil {
		t.Errorf("parsing with interval 60 should return err")
	}

	_, err = Parse("*/61 * * * * *")
	if err == nil {
		t.Errorf("parsing with interval 61 should return err")
	}

	_, err = Parse("2/60 * * * * *")
	if err == nil {
		t.Errorf("parsing with interval 60 should return err")
	}

	_, err = Parse("2-20/61 * * * * *")
	if err == nil {
		t.Errorf("parsing with interval 60 should return err")
	}
}

/******************************************************************************/

var benchmarkExpressions = []string{
	"* * * * *",
	"@hourly",
	"@weekly",
	"@yearly",
	"30 3 15W 3/3 *",
	"30 0 0 1-31/5 Oct-Dec * 2000,2006,2008,2013-2015",
	"0 0 0 * Feb-Nov/2 thu#3 2000-2050",
}
var benchmarkExpressionsLen = len(benchmarkExpressions)

func BenchmarkParse(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = MustParse(benchmarkExpressions[i%benchmarkExpressionsLen])
	}
}

func BenchmarkNext(b *testing.B) {
	exprs := make([]*Expression, benchmarkExpressionsLen)
	for i := 0; i < benchmarkExpressionsLen; i++ {
		exprs[i] = MustParse(benchmarkExpressions[i])
	}
	from := time.Now()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		expr := exprs[i%benchmarkExpressionsLen]
		next := expr.Next(from)
		next = expr.Next(next)
		next = expr.Next(next)
		next = expr.Next(next)
		next = expr.Next(next)
	}
}

========================================
pkg\cronexpr\example_test.go
/*!
 * Copyright 2013 Raymond Hill
 *
 * Project: github.com/gorhill/example_test.go
 * File: example_test.go
 * Version: 1.0
 * License: GPL v3 see <https://www.gnu.org/licenses/gpl.html>
 *
 */

package cronexpr

/******************************************************************************/

import (
	"fmt"
	"time"
)

/******************************************************************************/

// ExampleMustParse
func ExampleMustParse() {
	t := time.Date(2013, time.August, 31, 0, 0, 0, 0, time.UTC)
	nextTimes := MustParse("0 0 29 2 *").NextN(t, 5)
	for i := range nextTimes {
		fmt.Println(nextTimes[i].Format(time.RFC1123))
		// Output:
		// Mon, 29 Feb 2016 00:00:00 UTC
		// Sat, 29 Feb 2020 00:00:00 UTC
		// Thu, 29 Feb 2024 00:00:00 UTC
		// Tue, 29 Feb 2028 00:00:00 UTC
		// Sun, 29 Feb 2032 00:00:00 UTC
	}
}

========================================
prompt.go
package main

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	var content strings.Builder

	//   
	err := filepath.WalkDir(".", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		//   .go
		if !d.IsDir() && strings.HasSuffix(path, ".go") {
			data, err := os.ReadFile(path)
			if err != nil {
				return err
			}

			//     
			content.WriteString(fmt.Sprintf("\n%s\n%s\n", strings.Repeat("=", 40), path))
			content.Write(data)
		}
		return nil
	})

	if err != nil {
		fmt.Printf("  : %v\n", err)
		return
	}

	//   
	if err := os.WriteFile("prompt.txt", []byte(content.String()), 0644); err != nil {
		fmt.Printf(" : %v\n", err)
		return
	}

	fmt.Println("  prompt.txt")
}